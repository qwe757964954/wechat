{"version":3,"sources":["file:///Users/mac/work/WXGame_FlySmallChick/assets/framework/libs/Int64.ts"],"names":["Int64","constructor","a1","a2","buffer","offset","_buildHex","Array","Object","prototype","toString","call","apply","setValue","arguments","i","_HEX","_2scomp","b","o","carry","v","hi","lo","negate","length","Math","abs","VAL32","RangeError","replace","substr","parseInt","Error","toNumber","allowImprecise","x","m","MAX_INT","Infinity","valueOf","radix","toOctetString","sep","out","join","toBuffer","rawBuffer","compare","other","equals","inspect","MASK31","VAL31","MASK32","pow","MIN_INT"],"mappings":"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","sourcesContent":["//     Int64.js\n//\n//     Copyright (c) 2012 Robert Kieffer\n//     MIT License - http://opensource.org/licenses/mit-license.php\n\n/**\n * Support for handling 64-bit int numbers in Javascript (node.js)\n *\n * JS Numbers are IEEE-754 binary double-precision floats, which limits the\n * range of values that can be represented with integer precision to:\n *\n * 2^^53 <= N <= 2^53\n *\n * Int64 objects wrap a node Buffer that holds the 8-bytes of int64 data.  These\n * objects operate directly on the buffer which means that if they are created\n * using an existing buffer then setting the value will modify the Buffer, and\n * vice-versa.\n *\n * Internal Representation\n *\n * The internal buffer format is Big Endian.  I.e. the most-significant byte is\n * at buffer[0], the least-significant at buffer[7].  For the purposes of\n * converting to/from JS native numbers, the value is assumed to be a signed\n * integer stored in 2's complement form.\n *\n * For details about IEEE-754 see:\n * http://en.wikipedia.org/wiki/Double_precision_floating-point_format\n */\n\n//\n// Int64\n//\nexport class Int64 {\n  // Useful masks and values for bit twiddling\n  public static MASK31: number = 0x7fffffff;\n  public static VAL31: number = 0x80000000;\n  public static MASK32: number = 0xffffffff;\n  public static VAL32: number = 0x100000000;\n  public static MAX_INT: number = Math.pow(2, 53);\n  public static MIN_INT: number = -Math.pow(2, 53);\n  private static _HEX: Array<any> = new Array<any>();\n\n  public buffer: Array<number>;\n  public offset: number;\n\n  /**\n   * Constructor accepts any of the following argument types:\n   *\n   * new Int64(buffer[, offset=0]) - Existing Buffer with byte offset\n   * new Int64(Uint8Array[, offset=0]) - Existing Uint8Array with a byte offset\n   * new Int64(string)             - Hex string (throws if n is outside int64 range)\n   * new Int64(number)             - Number (throws if n is outside int64 range)\n   * new Int64(hi, lo)             - Raw bits as two 32-bit values\n   */\n  public constructor(a1: any, a2?: any) {\n    this._buildHex();\n    if (a1 instanceof Array) {\n      this.buffer = a1;\n      this.offset = a2 || 0;\n    }\n    else if (Object.prototype.toString.call(a1) == '[object Uint8Array]') {\n      // Under Browserify, Buffers can extend Uint8Arrays rather than an\n      // instance of Buffer. We could assume the passed in Uint8Array is actually\n      // a buffer but that won't handle the case where a raw Uint8Array is passed\n      // in. We construct a new Buffer just in case.\n      this.buffer = Array.apply([], a1);\n      this.offset = a2 || 0;\n    }\n    else {\n      this.buffer = this.buffer || [];\n      this.offset = 0;\n      this.setValue.apply(this, arguments);\n    }\n  }\n\n  // Map for converting hex octets to strings\n  private _buildHex(): void {\n    //Int64._HEX = [];\n    for (var i = 0; i < 256; i++) {\n      Int64._HEX[i] = (i > 0xF ? '' : '0') + i.toString(16);\n    }\n  }\n\n  /**\n   * Do in-place 2's compliment.  See\n   * http://en.wikipedia.org/wiki/Two's_complement\n   */\n  private _2scomp() {\n    var b = this.buffer, o = this.offset, carry = 1;\n    for (var i = o + 7; i >= o; i--) {\n      var v = (b[i] ^ 0xff) + carry;\n      b[i] = v & 0xff;\n      carry = v >> 8;\n    }\n  }\n\n  /**\n   * Set the value. Takes any of the following arguments:\n   *\n   * setValue(string) - A hexidecimal string\n   * setValue(number) - Number (throws if n is outside int64 range)\n   * setValue(hi, lo) - Raw bits as two 32-bit values\n   */\n  public setValue(hi: any, lo?: any): void {\n    var negate: boolean = false;\n    if (arguments.length == 1) {\n      if (typeof (hi) == 'number') {\n        // Simplify bitfield retrieval by using abs() value.  We restore sign\n        // later\n        negate = hi < 0;\n        hi = Math.abs(hi);\n        lo = hi % Int64.VAL32;\n        hi = hi / Int64.VAL32;\n        if (hi > Int64.VAL32) throw new RangeError(hi + ' is outside Int64 range');\n        hi = hi | 0;\n      } else if (typeof (hi) == 'string') {\n        hi = (hi + '').replace(/^0x/, '');\n        lo = hi.substr(-8);\n        hi = hi.length > 8 ? hi.substr(0, hi.length - 8) : '';\n        hi = parseInt(hi, 16);\n        lo = parseInt(lo, 16);\n      } else {\n        throw new Error(hi + ' must be a Number or String');\n      }\n    }\n\n    // Technically we should throw if hi or lo is outside int32 range here, but\n    // it's not worth the effort. Anything past the 32'nd bit is ignored.\n\n    // Copy bytes to buffer\n    var b = this.buffer, o = this.offset;\n    for (var i = 7; i >= 0; i--) {\n      b[o + i] = lo & 0xff;\n      lo = i == 4 ? hi : lo >>> 8;\n    }\n\n    // Restore sign of passed argument\n    if (negate) this._2scomp();\n  }\n\n  /**\n   * Convert to a native JS number.\n   *\n   * WARNING: Do not expect this value to be accurate to integer precision for\n   * large (positive or negative) numbers!\n   *\n   * @param allowImprecise If true, no check is performed to verify the\n   * returned value is accurate to integer precision.  If false, imprecise\n   * numbers (very large positive or negative numbers) will be forced to +/-\n   * Infinity.\n   * 如果为true，则不执行任何检查以验证返回值是否精确到整数精度。\n   * 如果为false，则不精确的数字（非常大的正数或负数）将强制为+/-无穷大。\n   */\n  public toNumber(allowImprecise: boolean = false): number {\n    var b = this.buffer, o = this.offset;\n\n    // Running sum of octets, doing a 2's complement\n    var negate = b[o] & 0x80, x = 0, carry = 1;\n    for (var i = 7, m = 1; i >= 0; i--, m *= 256) {\n      var v = b[o + i];\n\n      // 2's complement for negative numbers\n      if (negate) {\n        v = (v ^ 0xff) + carry;\n        carry = v >> 8;\n        v = v & 0xff;\n      }\n\n      x += v * m;\n    }\n\n    // Return Infinity if we've lost integer precision\n    if (!allowImprecise && x >= Int64.MAX_INT) {\n      return negate ? -Infinity : Infinity;\n    }\n\n    return negate ? -x : x;\n  }\n\n  /**\n   * Convert to a JS Number. Returns +/-Infinity for values that can't be\n   * represented to integer precision.\n   * 转换为JS编号。对于不能表示为整数精度的值，返回+/-无穷大。\n   */\n  public valueOf(): number {\n    return this.toNumber(false);\n  }\n\n  /**\n   * Return string value\n   *\n   * @param radix Just like Number#toString()'s radix\n   */\n  public toString(radix: number = 10): string {\n    return this.valueOf().toString(radix);\n  }\n\n  /**\n   * Return a string showing the buffer octets, with MSB on the left.\n   * 返回一个显示缓冲区八位字节的字符串，左边是MSB。\n   * @param sep separator string. default is '' (empty string)\n   */\n  public toOctetString(sep: string = ''): string {\n    var out = new Array(8);\n    var b = this.buffer, o = this.offset;\n    for (var i = 0; i < 8; i++) {\n      out[i] = Int64._HEX[b[o + i]];\n    }\n    return out.join(sep || '');\n  }\n\n  /**\n   * Returns the int64's 8 bytes in a buffer.\n   * 返回缓冲区中int64的8个字节。\n   * @param {bool} [rawBuffer=false]  If no offset and this is true, return the internal buffer.  Should only be used if\n   *                                  you're discarding the Int64 afterwards, as it breaks encapsulation.\n   * 如果没有偏移量且这是真的，则返回内部缓冲区。只有在以后丢弃Int64时才应使用，因为它会破坏封装\n   */\n  public toBuffer(rawBuffer: boolean = false): Array<number> {\n    if (rawBuffer && this.offset === 0) return this.buffer;\n\n    var out = Array.call([], this.buffer);\n    return out;\n  }\n\n  /**\n   * 比较\n   * Returns a number indicating whether this comes before or after or is the\n   * same as the other in sort order.\n   * 返回一个数字，指示该值是在排序顺序之前还是之后，或者与其他值相同。\n   * @param {Int64} other  Other Int64 to compare.\n   */\n  public compare(other: Int64): number {\n\n    // If sign bits differ ...\n    if ((this.buffer[this.offset] & 0x80) != (other.buffer[other.offset] & 0x80)) {\n      return other.buffer[other.offset] - this.buffer[this.offset];\n    }\n\n    // otherwise, compare bytes lexicographically\n    for (var i = 0; i < 8; i++) {\n      if (this.buffer[this.offset + i] !== other.buffer[other.offset + i]) {\n        return this.buffer[this.offset + i] - other.buffer[other.offset + i];\n      }\n    }\n    return 0;\n  }\n\n  /**\n   * Returns a boolean indicating if this integer is equal to other.\n   *\n   * @param {Int64} other  Other Int64 to compare.\n   */\n  public equals(other: Int64): boolean {\n    return this.compare(other) === 0;\n  }\n\n  /**\n   * Pretty output in console.log\n   */\n  public inspect(): string {\n    return '[Int64 value:' + this + ' octets:' + this.toOctetString(' ') + ']';\n  }\n}"]}